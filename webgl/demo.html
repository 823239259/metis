<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Demo</title>
    <style>
        *{margin: 0;padding: 0;}
        .canvas{position: fixed;width: 100%;height: 100%;cursor: pointer;}
    </style>
</head>
<body>
<canvas class="canvas"></canvas>
<script src="http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"></script>
<script src="../../common/libs/three.js"></script>
<script>
    var sketch = {

        /**
         * x轴: 紫
         * y轴: 蓝
         * z轴: 绿
         */

        canvas: null,
        scene: null,
        camera: null,
        renderer: null,

        ball: null,

        do: function () {
            var _this = this;
            _this.initThree();
            _this.initLight();
            _this.coordinate();
            _this.setObject();
            _this.handleAction();
            _this.renderScene();
        },
        initThree: function () {
            var _this = this;
            var $canvas = $('.canvas').get(0);
            var width = $canvas.clientWidth;
            var height = $canvas.clientHeight;

            /** 场景 **/
            var scene = new THREE.Scene();

            /** 相机 **/
            var camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
            camera.position.set(0, -50, 100);
            camera.up.set(0, 1, 0);
            camera.lookAt({x: 0, y: 0, z: 0});

            /** 渲染器 **/
            var renderer = new THREE.WebGLRenderer({
                canvas: $canvas,
                antialias: true // 反锯齿
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000);
            // 阴影
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = true;

            _this.canvas = $canvas;
            _this.scene = scene;
            _this.camera = camera;
            _this.renderer = renderer;
        },
        initLight: function () {
            var _this = this;
            var spot = new THREE.SpotLight(0xFFFF00, 1, 100, Math.PI / 3);
            var directional = new THREE.DirectionalLight(0xF8F8FF);

            /** 聚光灯 **/
            spot.position.set(0, 0, 50);
            spot.target.position.set(0, 0, 0);
            // 阴影
            spot.castShadow = true;
            spot.shadowCameraNear = 1;
            spot.shadowCameraFar = 100;
            spot.shadowCameraFov = 60;
            spot.shadowCameraVisible = true;

            /** 平行光 **/
            directional.position.set(-50, -50, 50);

            _this.scene.add(spot);
            _this.scene.add(directional);
        },
        coordinate: function () {
            var _this = sketch;
            var cooX = new THREE.Vector3(50, 0, 0);
            var cooY = new THREE.Vector3(0, 50, 0);
            var cooZ = new THREE.Vector3(0, 0, 50);
            var drawAxis = function (point, color) {
                var origin = new THREE.Vector3(0, 0, 0);
                var geometry = new THREE.Geometry();
                var material = new THREE.LineBasicMaterial({
                    color: color
                });
                geometry.vertices.push(origin, point);
                _this.scene.add(new THREE.Line(geometry, material, THREE.LinePieces));
            };

            // x 轴
            drawAxis(cooX, 0x4B0082);
            // y轴
            drawAxis(cooY, 0x0000FF);
            // z轴
            drawAxis(cooZ, 0x00FA9A);
        },
        setObject: function () {
            var _this = this;

            /** 地板 **/
            var cube = new THREE.CubeGeometry(50, 50, 5);
            var cubeMaterial = new THREE.MeshPhongMaterial({
                color: 0x58ACFA,
                opacity: 0.3
            });
            var board = new THREE.Mesh(cube, cubeMaterial);

            /** 弹球 **/
            var sphere = new THREE.IcosahedronGeometry(6);
            var sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x8A2BE2
            });
            var ball = new THREE.Mesh(sphere, sphereMaterial);

            /** 墙壁 **/
            var wall = [];
            for (var i = 0;i < 4;i++) {
                var offset = i % 2 ? -25 : 25;
                var plane = new THREE.CubeGeometry(50, 50, 1);
                var planeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x58ACFA,
                    opacity: 0.15
                });

                wall[i] = new THREE.Mesh(plane, planeMaterial);
                wall[i].position.z = 22.5;
                wall[i].receiveShadow = true;

                if (i < 2) {
                    wall[i].rotation.x = Math.PI / 2;
                    wall[i].position.y = offset;
                } else {
                    wall[i].rotation.y = Math.PI / 2;
                    wall[i].position.x = offset;
                }

                _this.scene.add(wall[i]);
            }

            // 阴影
            board.receiveShadow = true;
            ball.castShadow = true;

            board.position.set(0, 0, 0);
            ball.position.set(0, 0, 10);

            _this.scene.add(board);
            _this.scene.add(ball);

            _this.ball = ball;
        },
        handleAction: function () {
            var _this = this;
            var flag = false;
            var judge = null; // 边缘检测
            var $canvas = $(_this.canvas);
            var halfX = _this.canvas.clientWidth / 2;
            var halfY = _this.canvas.clientHeight / 2;

            /** 球体滚动 **/
            var scrollFun = function (e) {
                var dx = Math.abs(halfX - e.pageX) * 0.002;
                var dy = Math.abs(halfY - e.pageY) * 0.002;

                // x轴方向
                if (e.pageX < halfX) {
                    _this.ball.position.x -= dx;
                    _this.camera.position.x -= dx * 0.5;
                } else {
                    _this.ball.position.x += dx;
                    _this.camera.position.x += dx * 0.5;
                }

                // y轴方向
                if (e.pageY < halfY) {
                    _this.ball.position.y += dy;
                    _this.camera.position.y += dy * 0.5;
                } else {
                    _this.ball.position.y -= dy;
                    _this.camera.position.y -= dy * 0.5;
                }

                // 球体滚动
                _this.ball.rotation.x += Math.PI / 90;
                _this.ball.rotation.y += Math.PI / 90;
                _this.ball.rotation.z += Math.PI / 90;

                _this.renderScene();
            };
            /** 球体弹回 **/
            var bounceFun = function (e, judge) {
                // x轴方向
                if (judge.judgeX) {
                    if (e.pageX < halfX) {
                        _this.ball.position.x += 1;
                    } else {
                        _this.ball.position.x -= 1;
                    }
                }

                // y轴方向
                if (judge.judgeY) {
                    if (e.pageY < halfY) {
                        _this.ball.position.y -= 1;
                    } else {
                        _this.ball.position.y += 1;
                    }
                }
            };
            /** 边缘检测 **/
            var edgeJudge = function () {
                var x = _this.ball.position.x;
                var y = _this.ball.position.y;

                judge = {
                    judgeX: Math.abs(x) > 20,
                    judgeY: Math.abs(y) > 20
                };
            };


            $canvas.on('mousedown', function () {
                flag = true;
            });
            $canvas.on('mouseup', function () {
                flag = false;
            });
            $canvas.on('mousemove', function (e) {
                if (flag) {
                    // 边缘检测
                    edgeJudge();

                    var isEdge = judge.judgeX || judge.judgeY;
                    if (!isEdge) {
                        scrollFun(e);
                    } else {
                        bounceFun(e, judge);
                    }
                }
            });
        },
        renderScene: function () {
            var _this = this;
            _this.renderer.render(_this.scene, _this.camera);
        }
    };

    sketch.do();
</script>
</body>
</html>